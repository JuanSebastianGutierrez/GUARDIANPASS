# -*- coding: utf-8 -*-
"""Untitled36.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XfgQa8cQoodzg6yd6mVcLirRTAnU3kDF
"""

import sqlite3
import os
import string
import random
import hashlib
import customtkinter as ctk
from tkinter import messagebox
import sys

# Asegurarse de que el directorio de trabajo sea el mismo que el del ejecutable
if getattr(sys, 'frozen', False):
    os.chdir(os.path.dirname(sys.executable))

# Obtener la ruta absoluta para el archivo de base de datos
db_path = os.path.join(os.path.dirname(sys.executable), "contrasenas.db")

# Función para crear la tabla de usuarios
def crear_tabla_usuarios():
    try:
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS usuarios
                     (usuario TEXT PRIMARY KEY, contrasena TEXT)''')
        conn.commit()
    except sqlite3.Error as e:
        print(f"Error al crear la tabla de usuarios en SQLite: {e}")
    finally:
        conn.close()

# Función para hashear la contraseña
def hashear_contrasena(contrasena):
    return hashlib.sha256(contrasena.encode()).hexdigest()

# Función para registrar un nuevo usuario
def registrar_usuario(usuario, contrasena):
    try:
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        hashed_password = hashear_contrasena(contrasena)
        c.execute("INSERT INTO usuarios (usuario, contrasena) VALUES (?, ?)", (usuario, hashed_password))
        conn.commit()
    except sqlite3.IntegrityError:
        messagebox.showerror("Error", "El usuario ya existe.")
    except sqlite3.Error as e:
        print(f"Error al registrar usuario en SQLite: {e}")
    finally:
        conn.close()

# Función para validar el login
def validar_login(usuario, contrasena):
    try:
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        hashed_password = hashear_contrasena(contrasena)
        c.execute("SELECT * FROM usuarios WHERE usuario=? AND contrasena=?", (usuario, hashed_password))
        return c.fetchone() is not None
    except sqlite3.Error as e:
        print(f"Error al validar el login en SQLite: {e}")
        return False
    finally:
        conn.close()

# Ventana de login
def ventana_login():
    login_window = ctk.CTk()  # Ventana principal del login
    login_window.title("Iniciar Sesión")

    def intentar_login():
        usuario = entry_usuario.get().strip()
        contrasena = entry_contrasena.get().strip()
        if validar_login(usuario, contrasena):
            messagebox.showinfo("Login Correcto", "¡Bienvenido!")
            login_window.destroy()  # Cierra la ventana de login
            main()  # Inicia la aplicación principal después de un login exitoso
        else:
            messagebox.showerror("Error", "Usuario o contraseña incorrectos.")

    def registrar_nuevo_usuario():
        usuario = entry_usuario.get().strip()
        contrasena = entry_contrasena.get().strip()
        if usuario and contrasena:
            registrar_usuario(usuario, contrasena)
            messagebox.showinfo("Registro Exitoso", "¡Usuario registrado correctamente!")
        else:
            messagebox.showerror("Error", "Usuario y contraseña no pueden estar vacíos.")

    # Widgets de la ventana de login
    frame_login = ctk.CTkFrame(login_window)
    frame_login.pack(pady=10)

    lbl_usuario = ctk.CTkLabel(frame_login, text="Usuario:")
    lbl_usuario.grid(row=0, column=0, padx=5, pady=5)

    entry_usuario = ctk.CTkEntry(frame_login)
    entry_usuario.grid(row=0, column=1, padx=5, pady=5)

    lbl_contrasena = ctk.CTkLabel(frame_login, text="Contraseña:")
    lbl_contrasena.grid(row=1, column=0, padx=5, pady=5)

    entry_contrasena = ctk.CTkEntry(frame_login, show="*")
    entry_contrasena.grid(row=1, column=1, padx=5, pady=5)

    btn_login = ctk.CTkButton(frame_login, text="Iniciar Sesión", command=intentar_login)
    btn_login.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

    btn_registrar = ctk.CTkButton(frame_login, text="Registrar", command=registrar_nuevo_usuario)
    btn_registrar.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

    login_window.mainloop()  # Inicia el loop de eventos para la ventana de login

# Función para generar una contraseña aleatoria
def generar_contrasena(longitud=12):
    caracteres = string.ascii_letters + string.digits + string.punctuation
    contrasena = ''.join(random.choice(caracteres) for _ in range(longitud))
    return contrasena

# Función para crear la tabla de contraseñas si no existe
def crear_tabla_contrasenas():
    try:
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS contrasenas
                     (aplicacion TEXT PRIMARY KEY, contrasena TEXT)''')
        conn.commit()
    except sqlite3.Error as e:
        print(f"Error al crear la tabla en SQLite: {e}")
    finally:
        conn.close()

# Función para guardar contraseñas en la base de datos SQLite
def guardar_contrasenas_sqlite(aplicacion, contrasena):
    try:
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        c.execute("INSERT OR REPLACE INTO contrasenas (aplicacion, contrasena) VALUES (?, ?)", (aplicacion, contrasena))
        conn.commit()
    except sqlite3.Error as e:
        print(f"Error al guardar en SQLite: {e}")
    finally:
        conn.close()

# Función para mostrar las contraseñas en una nueva ventana dentro de la aplicación
def mostrar_contrasenas():
    try:
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        c.execute("SELECT aplicacion, contrasena FROM contrasenas")
        contrasenas = c.fetchall()
    except sqlite3.Error as e:
        print(f"Error al consultar contraseñas en SQLite: {e}")
        contrasenas = []
    finally:
        conn.close()

    if contrasenas:
        ventana_mostrar = ctk.CTkToplevel()
        ventana_mostrar.title("Contraseñas Guardadas")

        for aplicacion, contrasena in contrasenas:
            lbl = ctk.CTkLabel(ventana_mostrar, text=f"Aplicación: {aplicacion} - Contraseña: {contrasena}")
            lbl.pack(pady=5)
    else:
        messagebox.showinfo("Contraseñas Guardadas", "No hay contraseñas guardadas.")

def borrar_contrasena():
    """Mostrar una ventana para seleccionar y borrar una contraseña."""
    try:
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        c.execute("SELECT aplicacion FROM contrasenas")
        aplicaciones = [row[0] for row in c.fetchall()]
    except sqlite3.Error as e:
        print(f"Error al consultar aplicaciones en SQLite: {e}")
        aplicaciones = []
    finally:
        conn.close()

    if aplicaciones:
        ventana_borrar = ctk.CTkToplevel()
        ventana_borrar.title("Borrar Contraseña")

        lbl_aplicacion = ctk.CTkLabel(ventana_borrar, text="Seleccione la aplicación:")
        lbl_aplicacion.pack(padx=10, pady=10)

        variable_aplicacion = ctk.StringVar(ventana_borrar)
        variable_aplicacion.set(aplicaciones[0])

        opt_aplicacion = ctk.CTkOptionMenu(ventana_borrar, variable=variable_aplicacion, values=aplicaciones)
        opt_aplicacion.pack(padx=10, pady=10)

        def borrar():
            aplicacion = variable_aplicacion.get()
            try:
                conn = sqlite3.connect(db_path)
                c = conn.cursor()
                c.execute("DELETE FROM contraseñas WHERE aplicacion=?", (aplicacion,))
                conn.commit()
                messagebox.showinfo("Contraseña Borrada", f"La contraseña de la aplicación '{aplicacion}' ha sido borrada.")
            except sqlite3.Error as e:
                print(f"Error al borrar contraseña en SQLite: {e}")
            finally:
                conn.close()
                ventana_borrar.destroy()

        btn_borrar = ctk.CTkButton(ventana_borrar, text="Borrar", command=borrar)
        btn_borrar.pack(padx=10, pady=10)
    else:
        messagebox.showinfo("Borrar Contraseña", "No hay contraseñas para borrar.")

# Función principal de la aplicación
def main():
    crear_tabla_contrasenas()  # Crear la tabla de contraseñas si no existe

    ctk.set_default_color_theme("dark-blue")

    app = ctk.CTk()
    app.title("Gestor de Contraseñas")

    frame = ctk.CTkFrame(app)
    frame.pack(padx=20, pady=20)

    lbl_aplicacion = ctk.CTkLabel(frame, text="Aplicación:")
    lbl_aplicacion.grid(row=0, column=0, padx=10, pady=10)

    entry_aplicacion = ctk.CTkEntry(frame)
    entry_aplicacion.grid(row=0, column=1, padx=10, pady=10)

    lbl_contrasena = ctk.CTkLabel(frame, text="Contraseña:")
    lbl_contrasena.grid(row=1, column=0, padx=10, pady=10)

    entry_contrasena = ctk.CTkEntry(frame)
    entry_contrasena.grid(row=1, column=1, padx=10, pady=10)

    def guardar_contrasena():
        aplicacion = entry_aplicacion.get().strip()
        contrasena = entry_contrasena.get().strip()
        if aplicacion and contrasena:
            guardar_contrasenas_sqlite(aplicacion, contrasena)
            messagebox.showinfo("Guardado", "Contraseña guardada correctamente.")
        else:
            messagebox.showerror("Error", "Aplicación y contraseña no pueden estar vacíos.")

    btn_guardar = ctk.CTkButton(frame, text="Guardar Contraseña", command=guardar_contrasena)
    btn_guardar.grid(row=2, column=0, columnspan=2, padx=10, pady=10, sticky="ew")

    btn_mostrar = ctk.CTkButton(frame, text="Mostrar Contraseñas Guardadas", command=mostrar_contrasenas)
    btn_mostrar.grid(row=3, column=0, columnspan=2, padx=10, pady=10, sticky="ew")

    btn_borrar = ctk.CTkButton(frame, text="Borrar Contraseña", command=borrar_contrasena)
    btn_borrar.grid(row=4, column=0, columnspan=2, padx=10, pady=10, sticky="ew")

    app.mainloop()

# Crear la tabla de usuarios y lanzar la ventana de login
crear_tabla_usuarios()
ventana_login()